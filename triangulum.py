# -*- coding: utf-8 -*-
"""CDS411-Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZxasCc3Eg5ETjM7thcG0fM5-b3uZNrdU
"""

#----------------------------------------------------------------------+
# triagulum.py - file for CDS-411 Project.                             |
# Two-dimensional N-body simulation of the Triangulum Galaxy           |
#----------------------------------------------------------------------+

import numpy as np
import pandas as pd
import os

from plotnine import (
    ggplot, aes, geom_point, facet_wrap, coord_equal,
    theme_bw, labs, scale_color_manual
)
import matplotlib.pyplot as plt

# 0. Configuration
G = 1.0          # gravitational constant (scaled)
EPS = 0.01       # softening length
DT = 0.001       # time step
N_STEPS = 4000   # total integration steps
SNAPSHOT_STRIDE = 200   # save every 200 steps

N_STAR = 100     # number of visible "stars"
M_STAR = 1.0     # mass of one star

N_DM = 200       # number of dark-matter particles
M_DM = 2.5       # mass of one dark-matter particle

FIG_DIR = "figures"
os.makedirs(FIG_DIR, exist_ok=True)


# 1. Initialization
def init_visible_stars(n, r_max=1.0, v0=0.5, seed=0):
    """
    Initialize visible stars in a disk.
    r ~ sqrt(u) => more stars in outer region.
    v ~ r^(-1/2) (Kepler's third law), tangential direction.
    """
    rng = np.random.default_rng(seed)
    u = rng.random(n)
    r = r_max * np.sqrt(u)
    theta = 2 * np.pi * rng.random(n)

    x = r * np.cos(theta)
    y = r * np.sin(theta)

    # avoid division by zero near center
    r_safe = np.clip(r, 0.05, None)
    v = v0 / np.sqrt(r_safe)

    # tangential unit vector
    tx = -np.sin(theta)
    ty =  np.cos(theta)

    vx = v * tx
    vy = v * ty

    pos = np.stack([x, y], axis=1)
    vel = np.stack([vx, vy], axis=1)
    return pos, vel


def init_dark_matter(n_dm, r_min=0.3, r_max=1.5, v_disp=0.05, seed=1):
    """
    Initialize dark matter in a more extended halo.
    Radius distributed between r_min and r_max.
    Small random velocities.
    """
    rng = np.random.default_rng(seed)
    u = rng.random(n_dm)
    r = np.sqrt(r_min**2 + (r_max**2 - r_min**2) * u)
    theta = 2 * np.pi * rng.random(n_dm)

    x = r * np.cos(theta)
    y = r * np.sin(theta)

    vx = rng.normal(scale=v_disp, size=n_dm)
    vy = rng.normal(scale=v_disp, size=n_dm)

    pos = np.stack([x, y], axis=1)
    vel = np.stack([vx, vy], axis=1)
    return pos, vel


# 2. N-body gravity and integrator
def compute_acc(pos, masses):
    """
    Compute gravitational acceleration on each particle
    from all other particles (O(N^2)).
    pos: (N,2), masses: (N,)
    """
    diff = pos[:, None, :] - pos[None, :, :]   # r_i - r_j
    dist2 = (diff**2).sum(axis=2) + EPS**2
    inv_r3 = 1.0 / np.power(dist2, 1.5)
    np.fill_diagonal(inv_r3, 0.0)  # no self-force

    # acceleration a_i = -G * sum_j m_j (r_i - r_j) / r^3
    a = -G * (diff * inv_r3[:, :, None] * masses[None, :, None]).sum(axis=1)
    return a


def leapfrog(pos, vel, masses, dt, n_steps, snapshot_stride=100):
    """
    Velocity-Verlet / leapfrog integrator.
    Returns list of snapshots: (time, positions, velocities)
    """
    acc = compute_acc(pos, masses)
    vel_half = vel + 0.5 * dt * acc

    snapshots = []
    for step in range(n_steps):
        # drift
        pos = pos + dt * vel_half
        # new acceleration
        acc = compute_acc(pos, masses)
        # kick
        vel_half = vel_half + dt * acc

        if step % snapshot_stride == 0:
            t = step * dt
            vel_full = vel_half - 0.5 * dt * acc
            snapshots.append((t, pos.copy(), vel_full.copy()))

    return snapshots


# 3. Helpers to build DataFrames
def snapshots_to_dataframe(snapshots, n_star, n_dm=0):
    """
    Convert snapshots to a long DataFrame
    for facet plots.
    """
    records = []
    for t, pos, vel in snapshots:
        n_total = pos.shape[0]
        for i in range(n_total):
            kind = "star" if i < n_star else "dm"
            records.append((t, pos[i, 0], pos[i, 1], kind))
    df = pd.DataFrame(records, columns=["time", "x", "y", "kind"])
    return df


def rotation_curve_from_snapshot(pos, vel, idx_visible, n_bins=10):
    """
    Compute rotation curve (radius vs tangential velocity)
    using only visible stars.
    """
    pos_v = pos[idx_visible]
    vel_v = vel[idx_visible]

    x = pos_v[:, 0]
    y = pos_v[:, 1]
    r = np.sqrt(x**2 + y**2)
    theta = np.arctan2(y, x)

    # tangential unit vector
    tx = -np.sin(theta)
    ty =  np.cos(theta)

    v_tan = vel_v[:, 0] * tx + vel_v[:, 1] * ty

    bins = np.linspace(r.min(), r.max(), n_bins + 1)
    bin_idx = np.digitize(r, bins) - 1

    rows = []
    for b in range(n_bins):
        mask = bin_idx == b
        if mask.sum() >= 2:
            rows.append((r[mask].mean(), np.abs(v_tan[mask]).mean()))
    df = pd.DataFrame(rows, columns=["r", "v_tan"])
    return df


# 4. Run simulations
def run_visible_only():
    pos_star, vel_star = init_visible_stars(N_STAR)
    masses = np.ones(N_STAR) * M_STAR

    snapshots = leapfrog(
        pos_star, vel_star, masses,
        dt=DT, n_steps=N_STEPS,
        snapshot_stride=SNAPSHOT_STRIDE
    )
    return snapshots


def run_visible_plus_dm():
    pos_star, vel_star = init_visible_stars(N_STAR)
    pos_dm,   vel_dm   = init_dark_matter(N_DM)

    pos = np.vstack([pos_star, pos_dm])
    vel = np.vstack([vel_star, vel_dm])

    masses = np.concatenate([
        np.ones(N_STAR) * M_STAR,
        np.ones(N_DM) * M_DM
    ])

    snapshots = leapfrog(
        pos, vel, masses,
        dt=DT, n_steps=N_STEPS,
        snapshot_stride=SNAPSHOT_STRIDE
    )
    return snapshots


# 5. Plotting functions
def plot_facets(df, title, filename):
    df_plot = df.copy()
    # nicer facet labels
    df_plot["time_label"] = df_plot["time"].round(2).astype(str)

    p = (
        ggplot(df_plot, aes("x", "y", color="kind"))
        + geom_point(size=0.8)
        + facet_wrap("~time_label")
        + coord_equal()
        + scale_color_manual(values={"star": "red", "dm": "blue"})
        + theme_bw()
        + labs(title=title, x="x (arb. units)", y="y (arb. units)")
    )

    out_path = os.path.join(FIG_DIR, filename)
    p.save(out_path, dpi=300)
    print(f"Saved facet plot to {out_path}")


def plot_rotation_curves(df_vis, df_dm, filename):
    plt.figure()
    plt.plot(df_vis["r"], df_vis["v_tan"], marker="o", label="Visible only")
    plt.plot(df_dm["r"], df_dm["v_tan"], marker="s", label="Visible + dark matter")
    plt.xlabel("Radius (arb. units)")
    plt.ylabel("Tangential velocity (arb. units)")
    plt.title("Model rotation curves")
    plt.legend()
    plt.grid(True)

    out_path = os.path.join(FIG_DIR, filename)
    plt.savefig(out_path, dpi=300, bbox_inches="tight")
    plt.close()
    print(f"Saved rotation curve plot to {out_path}")


# 6. Main
def main():
    # 1) Visible-only model
    snaps_vis = run_visible_only()
    df_vis_pos = snapshots_to_dataframe(snaps_vis, N_STAR, 0)
    plot_facets(df_vis_pos,
                "Visible stars only (red)",
                "visible_only_facets.png")

    # last snapshot for rotation curve
    t_vis, pos_vis, vel_vis = snaps_vis[-1]
    df_vis_rc = rotation_curve_from_snapshot(
        pos_vis, vel_vis,
        idx_visible=np.arange(N_STAR)
    )

    # 2) Visible + dark matter model
    snaps_dm = run_visible_plus_dm()
    df_dm_pos = snapshots_to_dataframe(snaps_dm, N_STAR, N_DM)
    plot_facets(df_dm_pos,
                "Visible stars (red) + dark matter (blue)",
                "visible_plus_dm_facets.png")

    t_dm, pos_dm, vel_dm = snaps_dm[-1]
    df_dm_rc = rotation_curve_from_snapshot(
        pos_dm, vel_dm,
        idx_visible=np.arange(N_STAR)
    )

    # 3) Rotation curves
    plot_rotation_curves(df_vis_rc, df_dm_rc,
                         "rotation_curves.png")


if __name__ == "__main__":
    main()